//
// Generated by JTB 1.3.2
//

import visitor.*;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class TypeCheckVisitor extends GJDepthFirst<String,Map<String,String>> {
   //
   // User-generated visitor methods below
   //
   Integer assignment = 0, binop = 0, control = 0, function = 0;
   Map<String, String> class_hierarchy = new HashMap<String,String>();
   Map<String, HashMap<String, LinkedHashMap<String, String> > >  partialSymbolTable = new HashMap<String, HashMap<String, LinkedHashMap<String, String>>>();
   Map<String, HashMap<String, ArrayList<String> > >  partialSymbolTableCopy = new HashMap<String, HashMap<String, ArrayList<String>>>();
   String currClass, currMethod;
   Map<String, HashMap<String, String>> methodTypeMap = new HashMap<String, HashMap<String, String>>();
   Map<String, HashMap<String, String>> methodTypeMapCopy = new HashMap<String, HashMap<String, String>>();
   ArrayList<String> methodArguments;
   int methodPush =0;

   public int matchFunction(ArrayList<String> functionCall, String method, String Class){
      int ans = 0;
      // System.out.println(method + " " + Class);
      ArrayList<String> functionSignature = partialSymbolTableCopy.get(Class).get(method);
      // System.out.println(functionCall);
      // System.out.println(functionSignature);
      int calledSize = functionCall.size(), functionSize = functionSignature.size();
      for(int i=0; i< calledSize; i++){
         String arg1 = functionCall.get(i);
         String arg2 = functionSignature.get(i);
         if(arg1 == arg2 || (arg1 == "int" && arg2 == "float")){
            // System.out.println("yes match" + arg1 + " " + arg2);
            continue;
         }else if(partialSymbolTable.get(arg1)!= null && partialSymbolTable.get(arg2)!= null){
            if(hasAncestor(arg2, arg1)){
               // System.out.println("yes from class" + arg1 + " " + arg2);
               continue;
            }
            else ans++;
         }else ans++;
      }
      return ans;
   }
   public void copyMethod(String parent, String child){
      for( String met : partialSymbolTable.get(parent).keySet()){
         ArrayList<String> list = new ArrayList<String>();
         for(String argu : partialSymbolTable.get(parent).get(met).keySet()){
            list.add(partialSymbolTable.get(parent).get(met).get(argu));
         }
         methodTypeMapCopy.get(child).put(met, methodTypeMap.get(parent).get(met));
         partialSymbolTableCopy.get(child).put(met, list);
      }
   }

   public boolean isAssignCompatible(String left, String right, Map<String, String> argu){
      boolean ans = false;
      if(left == right ) return true;
      if((left == "float" && (right == "int" || right == "float"))) return true;
      if(partialSymbolTableCopy.get(left)!= null && partialSymbolTableCopy.get(right) != null) {
         return hasAncestor(left, right);
      }
      return ans;
   }




   
   public void copyMap(){
      for( String Class : partialSymbolTable.keySet()){
         partialSymbolTableCopy.put(Class, new HashMap<String, ArrayList<String>>());
         methodTypeMapCopy.put(Class, new HashMap<String, String>());
      }
      for(String child : class_hierarchy.keySet()){
         String parent = child;
         while(parent != null){
            copyMethod(parent, child);
            parent = class_hierarchy.get(parent);
         }
      }
      // System.out.println(partialSymbolTableCopy);
      // System.out.println(methodTypeMapCopy);
   }
   public boolean typeCompatibleNumber(String left, String right, Map<String , String> argu){
      boolean ans = false;
      if((left == "int" || left == "float" ) && (right == "int" || right == "float")){
         return true;
      }
      return ans;
   }
   public boolean typeCompatibleClass(String left, String right, Map<String , String> argu){
      boolean ans = false;
      if(hasAncestor(left, right) || hasAncestor(right, left)){
         return true;
      }
      return ans;
   }
   public boolean hasAncestor(String parent, String child){
      boolean ans = false;
      String temp = child;
      while(temp!= null){
         if(temp == parent){
            return true;
         }
         temp = class_hierarchy.get(temp);
      }
      return ans;
   }



   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */

   public void printFunction(){
      System.out.println("Assignment: " + assignment);
      System.out.println("Binop: " + binop);
      System.out.println("Control: " + control);
      System.out.println("Function: " + function);
      // System.out.println(methodTypeMap);
   }
   public String visit(Goal n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      argu = new HashMap<String, String>();
      copyMap();
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      printFunction();
      // System.out.println(partialSymbolTable);
      // System.out.println(class_hierarchy);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public String visit(MainClass n, Map<String,String> argu) {
      String _ret=null, temp;
      n.f0.accept(this, argu);
      temp = n.f1.accept(this, argu);
      currClass = temp;
      currMethod = "main";
      if(argu == null){
         partialSymbolTable.put(temp, new HashMap<String, LinkedHashMap<String, String>>());
         class_hierarchy.put(temp, null);
         methodTypeMap.put(temp, new HashMap<String, String>());
         methodTypeMap.get(temp).put("main", "void");
         partialSymbolTable.get(temp).put("main", new LinkedHashMap<String,String>());
      }
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      temp = n.f11.accept(this, argu);
      if( argu == null){
         partialSymbolTable.get(currClass).get("main").put("String[]", temp);
      }
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      if(argu != null ) argu = new HashMap< String, String>();
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( MethodDeclaration() )*
    * f4 -> "}"
    */
   public String visit(ClassDeclaration n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      currClass = _ret;
      if(argu == null){
         partialSymbolTable.put(_ret, new HashMap<String, LinkedHashMap<String, String>>());
         class_hierarchy.put(_ret, null);
      }
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( MethodDeclaration() )*
    * f6 -> "}"
    */
   public String visit(ClassExtendsDeclaration n, Map<String,String> argu) {
      String _ret=null, child, parent;
      n.f0.accept(this, argu);
      child = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      parent = n.f3.accept(this, argu);
      currClass = child;
      if(argu == null){
         partialSymbolTable.put(child, new HashMap<String, LinkedHashMap<String, String>>());
         class_hierarchy.put(child, parent);
      }
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n, Map<String,String> argu) {
      String _ret=null, varType, varName;
      varType = n.f0.accept(this, argu);
      varName = n.f1.accept(this, argu);
      // System.out.println(varType+ " " + varName);
      // argu.put(varName, varType);
      if(argu != null ) argu.put(varName, varType);
      // System.out.println(argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n, Map<String,String> argu) {
      String _ret=null, methodName, methodType, returnType;
      n.f0.accept(this, argu);
      methodType = n.f1.accept(this, argu);
      methodName = n.f2.accept(this, argu);
      currMethod = methodName;
      if(argu ==null){
         if(methodTypeMap.get(currClass)== null) methodTypeMap.put(currClass, new HashMap<String, String>());
         methodTypeMap.get(currClass).put(methodName, methodType);
         partialSymbolTable.get(currClass).put(methodName, new LinkedHashMap<String,String>());
      }else{
         argu = new HashMap<String, String>();
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      returnType = n.f10.accept(this, argu);
      if(argu!= null){
         if(argu.get(returnType) != null) returnType = argu.get(returnType);
         if(partialSymbolTable.get(currClass).get(currMethod).get(returnType) != null){
            returnType = partialSymbolTable.get(currClass).get(currMethod).get(returnType);
         }
         if(returnType != methodType){
            function++;
            if((methodType== "float" && returnType == "int") || hasAncestor(methodType, returnType)){
               function--;
            }
         }
      }
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n, Map<String,String> argu) {
      String _ret=null, paramType, paramName;
      paramType = n.f0.accept(this, argu);
      paramName = n.f1.accept(this, argu);
      if(argu ==null){
         partialSymbolTable.get(currClass).get(currMethod).put(paramName,paramType);
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> BooleanType()
    *       | IntegerType()
    *       | FloatType()
    *       | Identifier()
    */
   public String visit(Type n, Map<String,String> argu) {
      String _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> "float"
    */
   public String visit(FloatType n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public String visit(Statement n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public String visit(AssignmentStatement n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         // System.out.println(left + " " + right);
         if(argu.get(left)!= null) left = argu.get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left)!= null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(argu.get(right)!= null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right)!= null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         // System.out.println(left + " " + right);
         if(!isAssignCompatible(left, right, argu)){
            assignment+=1;
            // System.out.println("yes");
         }
      }
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public String visit(IfStatement n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(IfthenStatement n, Map<String,String> argu) {
      String _ret=null, controlType = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      controlType = n.f2.accept(this, argu);
      if(argu != null){
         if(controlType != "boolean" && controlType != null){
            control+=1;
         }
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfthenElseStatement n, Map<String,String> argu) {
      String _ret=null, controlType = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      controlType = n.f2.accept(this, argu);
      if(argu != null){
         if(controlType != "boolean" && controlType != null){
            control+=1;
         }
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n, Map<String,String> argu) {
      String _ret=null, controlType = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      controlType = n.f2.accept(this, argu);
      if(argu != null){
         if(controlType != "boolean" && controlType != null){
            control+=1;
         }
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      // System.out.println(argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public String visit(Expression n, Map<String,String> argu) {
      String _ret=null;
      _ret = n.f0.accept(this, argu);
      // if(argu != null) System.out.println(_ret);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(AndExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(left != "boolean" || right != "boolean"){
            binop+=1;
            return "error";
         }
         _ret = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(OrExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(left != "boolean" || right != "boolean"){
            binop+=1;
            return "error";
         }
         _ret = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(CompareExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(!typeCompatibleNumber(left, right, argu)){
            binop+=1;
            return "error";
         }
      }
      if( left !=null && right!= null ) _ret = "boolean";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   // not verified 
   public String visit(neqExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if( !typeCompatibleClass(left, right, argu) && !typeCompatibleNumber(left, right, argu)){
            binop+=1;
            return "error";
         }
         _ret = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(PlusExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         // System.out.println(left + " " + right);
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(!typeCompatibleNumber(left, right, argu)){
            binop+=1;
            // System.out.println(left + " " + right);
            return "error";
         }
      }
      if( left !=null && right!= null ) _ret = (left == "float" || right =="float" )? "float" : "int";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(MinusExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(!typeCompatibleNumber(left, right, argu)){
            binop+=1;
            return "error";
         }
      }
      if( left !=null && right!= null ) _ret = (left == "float" || right =="float" )? "float" : "int";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(TimesExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(!typeCompatibleNumber(left, right, argu)){
            binop+=1;
            return "error";
         }
      }
      if( left !=null && right!= null ) _ret = (left == "float" || right =="float" )? "float" : "int";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   //  verified
   public String visit(DivExpression n, Map<String,String> argu) {
      String _ret=null, left = null, right = null;
      left = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      right = n.f2.accept(this, argu);
      if(argu != null){
         if(argu.get(left) != null) left = argu.get(left);
         if(argu.get(right) != null) right = argu.get(right);
         if(partialSymbolTable.get(currClass).get(currMethod).get(left) != null) left = partialSymbolTable.get(currClass).get(currMethod).get(left);
         if(partialSymbolTable.get(currClass).get(currMethod).get(right) != null) right = partialSymbolTable.get(currClass).get(currMethod).get(right);
         if(!typeCompatibleNumber(left, right, argu)){
            binop+=1;
            return "error";
         }
      }
      if( left !=null && right!= null ) _ret = (left == "float" || right =="float" )? "float" : "int";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n, Map<String,String> argu) {
      String _ret=null, object, objMethod;
      // ArrayList<String> Argu = new ArrayList<String>();
      object = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      objMethod = n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      if(argu != null){
         if(object =="this") object = currClass;
         if(argu.get(object) != null ) object = argu.get(object);
         if(partialSymbolTable.get(currClass).get(currMethod).get(object) != null) object = partialSymbolTable.get(currClass).get(currMethod).get(object);
         methodArguments = new ArrayList<String>();
         n.f4.accept(this, argu);
         int temp = matchFunction(methodArguments, objMethod, object);
         function += temp;
         // System.out.println(temp);
         // System.out.println(methodArguments+ " " + objMethod + " " + object);
         _ret = methodTypeMapCopy.get(object).get(objMethod);
         // System.out.println(_ret);
      }
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return _ret;
   }


   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public String visit(ExpressionList n, Map<String,String> argu) {
      String _ret=null;
      _ret = n.f0.accept(this, argu);
      if(argu!= null){
         if(argu.get(_ret)!= null) _ret = argu.get(_ret);
         if(partialSymbolTable.get(currClass).get(currMethod).get(_ret)!= null) _ret = partialSymbolTable.get(currClass).get(currMethod).get(_ret);
         methodArguments.add(_ret);
      }
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public String visit(ExpressionRest n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      if(argu != null){
         methodArguments.add(_ret);
      }
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | FloatLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public String visit(PrimaryExpression n, Map<String,String> argu) {
      String _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, Map<String,String> argu) {
      String _ret="int";
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <FLOAT_LITERAL>
    */
   public String visit(FloatLiteral n, Map<String,String> argu) {
      // String _ret=null;
      n.f0.accept(this, argu);
      return "float";
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n, Map<String,String> argu) {
      // String _ret=null;
      n.f0.accept(this, argu);
      return "boolean";
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n, Map<String,String> argu) {
      // String _ret=null;
      n.f0.accept(this, argu);
      return "boolean";
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n, Map<String,String> argu) {
      // String _ret=null;
      n.f0.accept(this, argu);
      return "this";
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public String visit(NotExpression n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      if(argu!= null){
         if(_ret != "boolean" ) return "error";
      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public String visit(BracketExpression n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public String visit(IdentifierList n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public String visit(IdentifierRest n, Map<String,String> argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }
}
